name: Docker

on:
  workflow_dispatch:
  push:
    branches:
      - main
  schedule:
    - cron: "00 23 * * *"

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"

jobs:
  build:
    name: Pull
    runs-on: ubuntu-latest
    steps:
      - name: Before freeing up disk space
        run: |
          echo "Before freeing up disk space"
          echo "=============================================================================="
          df -hT
          echo "=============================================================================="

      # 增加可用磁盘空间
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: "true"
          remove-haskell: "true"
          # 如果空间还是不够用，可以把以下开启，清理出更多空间
          # remove-android: 'true'
          # remove-codeql: 'true'
          build-mount-path: "/var/lib/docker/"

      - name: Restart docker
        run: sudo service docker restart

      - name: Free up disk space complete
        run: |
          echo "Free up disk space complete"
          echo "=============================================================================="
          df -hT
          echo "=============================================================================="

      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Docker Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install skopeo and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq

      - name: Build and push image Aliyun
        run: |
          docker login -u $ALIYUN_REGISTRY_USER -p $ALIYUN_REGISTRY_PASSWORD $ALIYUN_REGISTRY
          # 数据预处理,判断镜像是否重名
          declare -A duplicate_images
          declare -A temp_map
          while IFS= read -r line || [ -n "$line" ]; do
              # 忽略空行与注释
              [[ -z "$line" ]] && continue
              if echo "$line" | grep -q '^\s*#'; then
                  continue
              fi
              
              # 获取镜像的完整名称，例如kasmweb/nginx:1.25.3（命名空间/镜像名:版本号）
              image=$(echo "$line" | awk '{print $NF}')
              # 将@sha256:等字符删除
              image="${image%%@*}"
              echo "image $image"
              # 获取镜像名:版本号  例如nginx:1.25.3
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              echo "image_name_tag $image_name_tag"
              # 获取命名空间 例如kasmweb,  这里有种特殊情况 docker.io/nginx，把docker.io当成命名空间，也OK
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              echo "name_space: $name_space"
              # 这里不要是空值影响判断
              name_space="${name_space}_"
              # 获取镜像名例如nginx
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
              echo "image_name: $image_name"
              
              # 如果镜像存在于数组中，则添加temp_map
              if [[ -n "${temp_map[$image_name]}" ]]; then
                   # 如果temp_map已经存在镜像名，判断是不是同一命名空间
                   if [[ "${temp_map[$image_name]}" != $name_space  ]]; then
                      echo "duplicate image name: $image_name"
                      duplicate_images[$image_name]="true"
                   fi
              else
                  # 存镜像的命名空间
                  temp_map[$image_name]=$name_space
              fi       
          done < images.txt


          while IFS= read -r line || [ -n "$line" ]; do
              # 忽略空行与注释
              [[ -z "$line" ]] && continue
              if echo "$line" | grep -q '^\s*#'; then
                  continue
              fi

              echo "docker pull $line"
              docker pull $line
              platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
              echo "platform is $platform"
              # 如果存在架构信息 将架构信息拼到镜像名称前面
              if [ -z "$platform" ]; then
                  platform_prefix=""
              else
                  platform_prefix="${platform//\//_}_"
              fi
              echo "platform_prefix is $platform_prefix"
              # 获取镜像的完整名称，例如kasmweb/nginx:1.25.3（命名空间/镜像名:版本号）
              image=$(echo "$line" | awk '{print $NF}')

              # 获取 镜像名:版本号  例如nginx:1.25.3
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              # 获取命名空间 例如kasmweb  这里有种特殊情况 docker.io/nginx，把docker.io当成命名空间，也OK
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              # 获取镜像名例  例如nginx
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')

              name_space_prefix=""
              # 如果镜像名重名
              if [[ -n "${duplicate_images[$image_name]}" ]]; then
                 #如果命名空间非空，将命名空间加到前缀
                 if [[ -n "${name_space}" ]]; then
                    name_space_prefix="${name_space}_"
                 fi
              fi
              
              # 将@sha256:等字符删除
              image_name_tag="${image_name_tag%%@*}"
              new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$platform_prefix$name_space_prefix$image_name_tag"
              echo "docker tag $image $new_image"
              docker tag $image $new_image
              
              # 使用 skopeo 检查镜像是否需要推送
              echo "检查镜像: $new_image"
              
              # 尝试获取远程镜像信息
              remote_info=$(skopeo inspect --creds $ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD docker://$new_image 2>/dev/null)
              skip_push=false
              
              if [ -n "$remote_info" ]; then
                  # 提取远程镜像摘要
                  remote_digest=$(echo "$remote_info" | jq -r '.Digest')
                  echo "远程镜像摘要: $remote_digest"
                  
                  # 获取本地镜像信息
                  local_info=$(skopeo inspect docker-daemon:$new_image 2>/dev/null)
                  if [ -z "$local_info" ]; then
                      echo "本地镜像检查失败，继续执行 push"
                  else
                      local_digest=$(echo "$local_info" | jq -r '.Digest')
                      echo "本地镜像摘要: $local_digest"
                      
                      # 比较摘要是否相同
                      if [ "$local_digest" == "$remote_digest" ]; then
                          echo "镜像内容相同，跳过 docker push"
                          skip_push=true
                          push_time=$(date -u "+%Y-%m-%d %H:%M")
                          curl -s -X POST https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage \
                            -d chat_id=${{ secrets.TELEGRAM_CHAT_ID }} \
                            -d parse_mode=Markdown \
                            --data-urlencode text="🔄 *镜像内容相同，跳过推送*  🕒 时间: ${push_time} UTC\`\`\`${new_image}\`\`\`"
                      fi
                  fi
              else
                  echo "远程仓库没有该镜像，准备 push"
              fi
              
              # 如果不跳过则执行推送
              if [ "$skip_push" = false ]; then
                  echo "docker push $new_image"
                  if docker push $new_image; then
                    push_time=$(date -u "+%Y-%m-%d %H:%M")
                    curl -s -X POST https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage \
                      -d chat_id=${{ secrets.TELEGRAM_CHAT_ID }} \
                      -d parse_mode=Markdown \
                      --data-urlencode text="🐳 *镜像推送成功！*  🕒 时间: ${push_time} UTC\`\`\`${new_image}\`\`\`"
                    
                  else
                    curl -s -X POST https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage \
                      -d chat_id=${{ secrets.TELEGRAM_CHAT_ID }} \
                      -d text="❌ 镜像推送失败: $new_image"
                  fi
              fi
              
              echo "开始清理磁盘空间"
              echo "=============================================================================="
              df -hT
              echo "=============================================================================="
              docker rmi $image
              docker rmi $new_image
              echo "磁盘空间清理完毕"
              echo "=============================================================================="
              df -hT
              echo "=============================================================================="     
              
          done < images.txt
